## 第一题
10 分
复制样例。

$30 \sim 50$ 分
各种暴力。
一种 50 分的做法是: dfs 所有的序列, 先 $\mathrm{dfs}$ 序列和, 再从小到大 $\mathrm{dfs}$ 序列中的每一个元素。输出够了 $r$ 个字符就退出。稍微剪枝即可。注意你很 容易判断一个状态最后能不能到达某一个合法状态, 不合法的直接停掉, 这 样复杂度还是很有理有据的与 $r$ 是线性的数量关系。

70 分
考虑令 $f_{i, j, k}$ 为第 $i$ 个素数以后构成的, 序列和为 $j$, 长度为 $k$ 的素数 导出序列个数。
$g_{i, j, k}$ 为第 $i$ 个素数以后构成的, 序列和为 $j$, 长度为 $k$ 的素数导出序 列对应的字符串的总长度。
显然我们可以递推 $f, g$, 这是一个基础背包。
考虑复杂度, 根据计算发现, 第 $10^{18}$ 个字符大约是在和 $s=735$ 的时 候取到, 所以总状态数有 $\pi(s) s^2 / 2 \approx 3.5 \times 10^7$ 个, 可以通过。
那么我们每次想知道一个字符, 只需要像 50 分一样, 大力 $\mathrm{dfs}$, 根据 $f, g$ 判断下面的分支的大小, 进人适当的分支, 就可以了。

100 分
稍微优化一下, 我们发现我们可以不一个个字符 $\mathrm{dfs}$, 而是可以一次 $\mathrm{dfs}$ 求出所有字符, 就可以过了。

## 第二题
20 分
答案为 $\frac{m\left(m^n-1\right)}{m-1}$
设答案为 $x$, 则可以枚举与 $B$ 的公共前缀长度, 则 $x=\sum_{i=1}^n(x+i) \frac{m-1}{m^i}+$ $\frac{n}{m^n}$, 解得 $x=\frac{m\left(m^n-1\right)}{m-1}$ 。

50 分
当 $n=2$, 若 $B_1 \neq B_2$, 则答案 $=m^2$ 若 $B_1=B_2$, 答案 $=m(m+1)$ 相同的已经讨论过了, 不同的则是:
令 $x$ 为答案 $y$ 为钦定第一个是 $B_1$ 的答案。
$y=\frac{1}{m}+\frac{1}{m}(y+1)+\frac{m-2}{m}(x+1), x=\frac{1}{m}(y+1)+\frac{m-1}{m}(x+1)$
易得 $x=m^2$

80 分
考虑这个东西与字符串匹配很像, 我们考虑先对 $B$ 跑 $\mathrm{kmp}$, 这样令 $d p_x$ 代表钦定前 $x$ 个已经匹配的期望, 考虑枚举下一个字符, 即可列方程 $O\left(n^3\right)$ 求解。
具体来讲, $a_x$ 代表前面已经匹配了前 $x$ 个之后的期望, 然后就是 $a_x=$ $1+\frac{1}{m} \sum_{j=1}^m a_{\operatorname{trans}(x, j)}$
如果实现不够精细可能会被卡常, 但是其实注意到这个方程组几乎就 是一个上三角矩阵, 故可以 $O\left(n^2\right)$ 求解, 就不卡常了。

100 分
如果你会打表猜结论, 那么你大概可以猜出来答案是 $m^n+\sum_{p \in P} m^p$ 其中 $P$ 为 $B$ 的 Border 集合, 这是对的。
还是 $\mathrm{kmp}$, 我们考虑这样一个事情:
维护一个人的集合, 每次试图匹配下一个字符的时候：

- 加人一个人, 这个人有 1 元钱
- 若某个人有 $m^i$ 元钱, 则他将用全部的钱奢接下来选的数是 $B_{i+1}$
- 均匀随机的选一个 $[1, m]$ 的数 (这就是匹配下一个的过程)
- 对于所有猜中的人, 给他投注的钱翻 $m$ 倍, 否则, 全部输光
  

由于每个人有 $\frac{1}{m}$ 的概率钱翻 $m$ 倍, 剩下的概率输光, 所以每个人期望 一直只有 1 元钱。
而所有人总钱数的期望, 就是当前匹配的字符串长度。
考虑我们何时停止: 若一个人有了 $m^n$ 元钱, 就可以停止了, 而此时所 有人的总钱数是 $m^n+\sum_{p \in P} m^p$ 其中 $P$ 为 $B$ 的 Border 集合 (我们发现除 了这些人其它的肯定都输光了)。
那么我们第一次停止时, 所有人一共有的钱数, 就等于字符串长度的期 望
所以答案就是上面的那个柿子。

# 第三题

20 分
暴力, 可以做到 $O\left(n^2 m\right)$ 之类的东西

40 分
考虑枚举左端点, 然后不断扩大右端点, 由于一个子串是否合法是一个 “莫队信息”, 所以可以做到 $O\left(n^2\right)$

70 分
考虑一种 $O(n m)$ 的做法: 考虑处理出每个位置 $i$ 为结尾的前绕各个数 字出现次数的数组 $V_i$, 则 $(l, r]$ 合法当且仅当 $V_r-V_l$ 各项相同。
我们发现这等价于 $V_l, V_r$ 的差分数组相同。于是枚举右端点, 维护每个 位置 $V_i$ 差分数数组的集合, 最后看有多少个匹配就好了。维护这个东西可 使用哈希表, 平衡树或者字典树都可以。

$70 \sim 100$ 分
考虑一种 $O\left(n^2 / m\right)$ 的做法, 因为合法区间只有 $n / m$ 种不同的长度, 我 们可以枚举每个长度的所有区间, 由于 “莫队信息”, 可以 $O(n)$ 完成检查, 与 $O(n m)$ 做法结合可以得到一个最高 $O(n \sqrt{n})$ 的做法, 得分取决于实现常 数。较为优秀的可以获得 80 分, 极为优秀的可以获得满分。

100 分
我们发现这个这个 $V_i$ 的差分数组每次改变量是 $O(1)$ 的, 进而哈希值 的改变量也是 $O(1)$ 的, 所以可以每次直接 $O(1)$ 修改哈希值, 然后手写一个 unordered_map 就可以过了, STL 的平衡树大概过不去。复杂度 $O(n+m)$

# 第四题

真正的良心送分题
$i$ 和 $2 \times i 、 2 \times i+1$ 形成了一个树结构, 直接树形 $\mathrm{DP}$ 。
$f(u, i, j, o p)$ 表示 $u$ 为根的子树在集合一放了 $i$ 个, 集合二放了 $j$ 个, $u$ 在集合 $o p$ 的最大贡献 枚举转移, 可以拿到 $80 \mathrm{pts}$ 。
显然只要我们确定子树内集合一的点数, 集合二内的点数可以确定。 $f(u, i, o p)$ 表示 $u$ 子树集合一选了 $i$ 个, $u$ 在集合 $o p$ 内的最大贡献。只记录集合一内的点数即可获得满分。