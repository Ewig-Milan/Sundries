### 剪切字符串

两个字符串 LCP 肯定不超过两者长度较小值，所以取 $i=n-2, j = n - 1$ 时答案不会超过 $3$。

接下来只需要考虑小于 $3$ 的答案即可。我们下面也称切出的三段字符串分别为 $a,b,c$。

一个直接的思路是枚举 $i,j$ 统计答案。考虑当前已经枚举了一个 $i$，如何找到最优的 $j$。对于 $b$ 的长度 $\lt 3$ 的所有答案可以暴力枚举 $j$，只有 $O(1)$ 种。如果 $b$ 的长度 $\gt 3$，我们就不需要考虑 $j$ 的选取对 $a, b$ 字符串的影响，于是只考虑 $LCP(a,c)$ 和 $LCP(b,c)$ 的贡献。

可以让 $LCP(a,c)+LCP(b,c)=0$ 当且仅当存在 $c_j\neq a_1\land c_j\neq b_i$。否则：如果 $a_1\neq b_i$，我们选 $j = n - 1$ 就有 $LCP(a,c)+LCP(b,c)=1$，最优；如果 $a_1 = b_i$，那后面的 $c_j$ 也都和它们相等，$LCP(a,c)+LCP(b,c)\ge 2$，还是选 $j=n-1$ 最优。

所以总的算法是：枚举 $i$，然后检查是否存在 $c_j$ 和 $a_1,b_i$ 都不相等，并暴力枚举 $j=i+1,i+2,i+3,n-1$ 这几种情况，最优解一定存在于这些情况中。

实现精细的话时间复杂度 $O(n)$，如果随意用 `std::map` 统计，时间复杂度是 $O(n\log \lvert\Sigma\rvert)$ 的，也能通过本题。



## 深度优先搜索树

题意就是问有多少个图的深度优先搜索树是给定的树。

题目代码给定了每个点孩子的访问顺序是编号从小到大，所以可以直接得到每个点的 dfs 序。

考虑 dfs 过程，可以发现树边一定存在，非树边如果是横叉边（两端点在 dfs 树上不是祖孙关系）则一定不存在（否则先 dfs 到其中一端的时候一定会让另一端在这个 dfs 树的子树里），如果是返祖边（祖先到子孙）则在子孙点编号大于它在 dfs 树上所在祖先子树的编号（也就是到祖先点路径的倒数第二个点的编号）时可以存在，否则也不能存在。

综合起来，结论是所有树边一定存在，一部分非树边一定不存在，其余非树边可以存在也可以不存在且每条边状态都互相独立任选。那么答案等于 $2^c$，其中 $c$ 是可存在可不存在的非树边个数。我们称这些非树边是合法的。

根据上述讨论，一条非树边合法当且仅当它是祖孙边，且子孙点所属的祖先点的子树的根编号小于子孙点的编号。那么合法的边数总数其实就是满足以下条件的 $(u,v)$ 点对数：

1. $u$ 是 $v$ 的祖先。
2. $u\lt v$
3. $u$ 不是根。（$u\ne 1$）

这样，$u$ 父亲和 $v$ 之间的边是合法的。

要统计这样的点对数，只要统计每个点到根路径上编号小于自己的点数之和。dfs 一遍，用树状数组或者其它数据结构在 dfs 过程中维护当前点到根路径上的点集即可。

时间复杂度：$O(n\log n)$



## 巡逻网络

## $k = 1$

先来考虑 $k=1$，也即一维的情况。

整个题的贡献可以拆为三个部分：固定点内部互相的贡献、固定点与可选点之间的贡献、可选点内部互相的贡献。

第一种贡献是个定值，可以预处理出来；第二种贡献相当于在选择可选点的时候每个点会有一个额外权值，所以我们主要考虑第三部分，也即可选点内部之间的贡献如何处理。

考虑可选点，由于我们要求的是**最大**的曼哈顿距离和，且注意到绝对值本身就可以理解成最大值：

$$|a|+|b|=\max(a+b,a-b,-a+b,-a-b).$$

也就是说，绝对值此时无关紧要，我们只需要考虑安排好每个数每一维正负号的贡献就好了。

举个例子，假设已经选好了 $m$ 个点，那么你可以先排序成  $x_1\le x_2\le \cdots\le x_m$，然后你按贡献计算 $\sum_{i=1}^m(2i-m-1)x_i=\sum_{i\ne j}|x_i-x_j|$。我们实际上只需要枚举 $m!$ 种排列，然后将 $\sum_{i=1}^m(2i-m-1)x_i$ 的最大值算出来。

所以在一维的情况下，自然可以设一个 DP 出来：设 $f(i, S)$ 表示前 $i$ 个点中，已经钦定了一些点位于 $S$ 这些位置的情况下，所能产生的贡献最大值。此处的 $S$ 应当是 $m$ 位二进制数。也就是相当于用状压DP枚举了点坐标大小的 $m!$ 种排列。

转移时，把第 $i$ 个点放到第 $p$ 个位置，贡献将会是 $(2p - m - 1)x _i + c _i$，其中 $c _i$ 表示第 $i$ 个点与其他固定点之间的贡献。如此状压 DP，复杂度是 $O(n m2^m)$，其中 $n$ 代表可选点数，也即 $m + t$。

## $k = 2$

其实本质上也没有什么区别，只是现在选择第 $i$ 个点之后要同时考虑 $x _i$ 和 $y _i$ 的位置。

设 $f(i, S_1, S_2)$ 表示前 $i$ 个点中，已经钦定了一些点的 $x$ 坐标占据了 $S_1$ 的位置，$y$ 坐标占据了 $S_2$ 的位置，所能产生的贡献最大值。

转移时，把第 $i$ 个点的 $x$ 坐标放到 $p _1$ 的位置，$y$ 坐标放到 $p _2$ 的位置，贡献将会是 $(2p _1 - m - 1)x _i + (2p _2 - m - 1)y _i + c _i$，复杂度粗略估计一下大概是 $O(nm^2 4^m)$，已经可以过了。

但是注意到，$S _1$ 和 $S_2$ 互相之间是有限制的，因为他们总需要保证出现的点数相同，不可能会是 $O(4 ^m)$ 级别的状态量。实际上考虑枚举两个状态中出现的点数 $k$，状态量应当为

$$
\sum _{k = 0}^m {m \choose k}^2,
$$

这是 $O(\frac {4^m} {\sqrt m})$ 的。

拓展：考虑一下有多次询问的情况，以及 $k=3,4$ 的情况怎么做？



## [彩色括号](https://uoj.ac/contest/96/problem/958)

本题之前在 UOJ958 考过。

### 思路

问题研究对象是满足条件的括号序列：整体合法且删掉每种单个颜色之后都合法，那么考虑怎么判断一个括号序列是否满足条件。

括号序列合法当且仅当：

1. 左右括号个数相等
2. 所有前缀和非负（将 `()` 分别视为 $+1,-1$）

分别考虑：

1. 由于整体左右括号个数相等且删掉红色之后左右括号个数还是相等，作差可以得到红色左右括号个数相等。同理每个颜色都如此。
2. 考虑某个位置 $i$ 的前缀和，设红绿蓝的前缀和分别是 $a,b,c$，那么 $a+b,a+c,b+c,a+b+c\ge 0$。可以发现当 $a+b,a+c,b+c\ge 0$ 同时成立时，全部相加可得 $2(a+b+c)\ge 0$。所以 $a+b+c\ge 0$ 这个条件不用单独考虑。

所以总的条件是：

1. 每种颜色左右括号个数都相等。
2. 删掉每种颜色得到的前缀和分别非负。

这是判断条件。现在我们再考虑如何用最少的修改次数让一个括号序列合法，发现：

- `)` 改 `(` 一定是前若干个 `)`，`(` 改 `)` 一定是最后若干个 `(`。可以调整证明。
- 所以可以贪心：如果某种括号多，那么先改那种括号到左右括号数量平衡。然后从外往里每次将第一个 `)` 和最后一个 `(` 一起修改，直到前缀和全部非负为止。这就是最小修改次数。

加上颜色限制后，每种颜色内部还是符合这个条件。所以我们不妨先把每种颜色都改到数量平衡，设这样改完后的整个序列是 $a'$。

然后设 $x_1,x_2,x_3$ 分别表示三种颜色从外往里多改了多少对括号。我们目标是最小化 $\sum x_i$。

考虑合法性对 $x_i$ 的约束，现在的约束只剩下删掉每种单个颜色时每个前缀和都必须 $\ge 0$。

对于前缀 $j$ 来说，颜色 $i$ 增加的前缀和是 $\min(x_i,A_{i,j},B_{i,j})$，其中 $A_{i,j}$ 是前缀 $a'[1,j]$ 中 `)` 个数，而 $B_{i,j}$ 是后缀 $a'[j+1,n]$ 中 `(` 个数。另外设 $C_{i,j}$ 表示一开始颜色 $i$ 在 $a'$ 的前缀和。

可以列出不等式组：

$$
(\forall k, j) \sum_{i\ne k} (C_{i,j}+\min(x_i,A_{i,j},B_{i,j}))\ge 0
$$

将 $\min(\cdot,\cdot)\ge 0$ 拆开成 $\cdot \ge 0\land \cdot \ge 0$ 的形式，全部整理完以及合并同类项后可以得到一个不等式组：

$$
(\forall S\subsetneq U, S\ne\emptyset) \sum_{i\in S} x_i\ge C_S
$$

其中 $U$ 表示所有颜色的集合 $\{1,2,3\}$，$C_S$ 是一个算出来的由 $S$ 决定的常数。

所以整个问题就是在这个约束下最小化 $\sum x_i$。因为颜色很少，三维空间上每个限制是一个平面，直接在每个面上都双指针枚举判定其它限制下的最优解即可。当颜色数更大时可以当成较一般的整数规划问题。

三种颜色的约束的几何图像是在这个图的形状上求离原点曼哈顿距离最近的点：

![图](https://img.uoj.ac/problem/958/329A44D3E9D0F22285FCE984B9802D82.png)

### 算法

按照思路所说，先做让每种颜色左右括号数量平衡必要的修改得到 $a'$，然后枚举前缀算出 $A,B,C$ 数组，合并算出不等式组。

三种颜色的情况下，可以看成三个形如 $x_1\ge \cdot\land x_2\ge \cdot\land x_1+x_2\ge \cdot$ 的三段折线的二维偏序约束进行合并。两两枚举用双指针算出它们相交的折线，然后第三个约束在折线上的效果是约束折线只能取前一半。枚举所有折线上的点更新答案即可，一共 $O(n)$ 个。

或者你可以直接把它当成实数线性规划手算每个极值点然后向上取整得到整数解，再求这些解的最值，在本题中这是对的。

时间复杂度：$O(n)$

### 部分分

如果你没有发现不等式组，可以用双指针和区间数据结构算出每两种颜色的约束。（没有不等式组不容易发现约束只有三段，但至少可以发现是二维偏序上的阶梯型）

然后仍然可以 $O(n)$ 合并三个二维偏序约束算出答案。

时间复杂度：$O(n\log n)$

如果你只发现了一部分性质，可以做更前面的部分分。